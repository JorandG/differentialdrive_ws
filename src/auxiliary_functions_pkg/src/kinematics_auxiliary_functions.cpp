/* -------------------------------------------------------------------------- */
/*                                  INCLUDES                                  */
/* -------------------------------------------------------------------------- */
#include <auxiliary_functions_pkg/kinematics_auxiliary_functions.h>
/* -------------------------------------------------------------------------- */

/* -------------------------------------------------------------------------- */
/*                            FUNCTIONS DEFINITIONS                           */
/* -------------------------------------------------------------------------- */

/* ------------------------------- Skew Matrix ------------------------------ */
Eigen::MatrixXd get_skew_matrix(Eigen::VectorXd vector_)
{
	/**================================================================================================
	 *                                         DESCRIPTION
	 * 
	 * Computes and returns the skew matrix associated with the passed-in 3x3 vector.
	 *================================================================================================**/

	/* --------------------------- Auxiliary variables -------------------------- */
	Eigen::MatrixXd skew_matrix;
	/* -------------------------------------------------------------------------- */

	/* ------------------------ Variables initialization ------------------------ */
	skew_matrix = Eigen::MatrixXd::Zero(3,3);
	/* -------------------------------------------------------------------------- */

    /* ---------------------------------- Body ---------------------------------- */
    skew_matrix(0,1) = -vector_(2);
    skew_matrix(0,2) = vector_(1);

    skew_matrix(1,0) = vector_(2);
    skew_matrix(1,2) = -vector_(0);

    skew_matrix(2,0) = -vector_(1);
    skew_matrix(2,1) = vector_(0);
	/* -------------------------------------------------------------------------- */

    return skew_matrix;
}
/* -------------------------------------------------------------------------- */

/* ----------------------- Elementary Rotation Matrix ----------------------- */
Eigen::Matrix3d get_elementary_rotation_matrix(double alpha, axes rotation_axis)
{
	/**================================================================================================
	 *                                         DESCRIPTION
	 * 
	 * Computes and returns the elementary rotation matrix associated with the specified angle and 
	 * rotation axis
	 *================================================================================================**/

	/* --------------------------- Auxiliary Variables -------------------------- */
	Eigen::Matrix3d R;
	/* -------------------------------------------------------------------------- */

	/* ------------------------ Variables Initialization ------------------------ */
	R = Eigen::Matrix3d::Identity();
	/* -------------------------------------------------------------------------- */

	/* ---------------------------------- Body ---------------------------------- */

	/* --------------- Rotation by an angle 'alpha' about axis 'x' -------------- */
	if(rotation_axis == axes::x_axis)
		R << 1, 0, 0,
			 0, std::cos(alpha), -std::sin(alpha),
			 0, std::sin(alpha),  std::cos(alpha);
	/* -------------------------------------------------------------------------- */

	/* --------------- Rotation by an angle 'alpha' about axis 'y' -------------- */
	else if(rotation_axis == axes::y_axis)
		R << std::cos(alpha), 0, std::sin(alpha),
			 0, 1, 0,
			 -std::sin(alpha), 0, std::cos(alpha);
	/* -------------------------------------------------------------------------- */

	/* --------------- Rotation by an angle 'alpha' about axis 'z' -------------- */
	else if(rotation_axis == axes::z_axis)
		R << std::cos(alpha), -std::sin(alpha), 0,
		     std::sin(alpha), std::cos(alpha), 0,
			 0, 0, 1;
	/* -------------------------------------------------------------------------- */

	/* -------------------------------------------------------------------------- */

	return R;
}
/* -------------------------------------------------------------------------- */

/* ------------------------- ROT-2-QUAT - QUAT-2-ROT ------------------------ */
Eigen::VectorXd rot2quat(Eigen::MatrixXd R)
{
	/**================================================================================================
	 *                                         DESCRIPTION
	 * 
	 * Computes and returns the unit quaternion associated with the passed-in rotation matrix.
	 *================================================================================================**/

	/* --------------------------- Auxiliary variables -------------------------- */
	Eigen::Quaterniond _Q;
	Eigen::VectorXd Q(4);
	/* -------------------------------------------------------------------------- */

	/* ------------------------ Variables initialization ------------------------ */
	_Q = Eigen::Matrix3d(R);
	/* -------------------------------------------------------------------------- */
	
	/* ---------------------------------- Body ---------------------------------- */
	Q << _Q.x(), _Q.y(), _Q.z(), _Q.w();
	/* -------------------------------------------------------------------------- */

    return Q;
}

Eigen::Matrix3d quat2rot(Eigen::VectorXd e)
{
	/**================================================================================================
	 *                                         DESCRIPTION
	 * 
	 * Computes and returns the rotation matrix associated with the passed-in unit quaternion.
	 *================================================================================================**/

	/* --------------------------- Auxiliary variables -------------------------- */
	double t[10];
	Eigen::Matrix3d R;
	/* -------------------------------------------------------------------------- */
	
	/* ------------------------ Variables initialization ------------------------ */
	t[0] = pow(e[0],2); //x^2
	t[1] = pow(e[1],2); //y^2
	t[2] = pow(e[2],2); //z^2
	t[3] = pow(e[3],2); //eta^2
	t[4] = e[0]*e[1]; //x*y
	t[5] = e[0]*e[2]; //x*z
	t[6] = e[1]*e[2]; //y*z
	t[7] = e[3]*e[0]; //eta*x
	t[8] = e[3]*e[1]; //eta*y
	t[9] = e[3]*e[2]; //eta*z
	/* -------------------------------------------------------------------------- */

	/* ---------------------------------- Body ---------------------------------- */

	/* -------------------------------- First row ------------------------------- */
	R(0,0) =  2 * (t[3] + t[0]) - 1;
	R(0,1) = 2 * (t[4] - t[9]);
	R(0,2) = 2 * (t[5] + t[8]);
	/* -------------------------------------------------------------------------- */

	/* ------------------------------- Second row ------------------------------- */
	R(1,0) = 2 * (t[4] + t[9]);
	R(1,1) = 2 * (t[3] + t[1]) -1;
	R(1,2) = 2 * (t[6] - t[7]);
	/* -------------------------------------------------------------------------- */

	/* -------------------------------- Third row ------------------------------- */
	R(2,0) = 2 * (t[5] - t[8]);
	R(2,1) = 2 * (t[6] + t[7]);
	R(2,2) = 2 * (t[3] + t[2]) - 1;
	/* -------------------------------------------------------------------------- */

	/* -------------------------------------------------------------------------- */

	return R;
}
/* -------------------------------------------------------------------------- */

/* ------------------------- RPY-2-QUAT - QUAT-2-RPY ------------------------ */
Eigen::VectorXd rpy2quat(Eigen::Vector3d rpy)
{
	/**================================================================================================
	 *                                         DESCRIPTION
	 * 
	 * Computes and returns the unit quaternion associated with the passed-in Eulers' angles
	 *================================================================================================**/

	/* --------------------------- Auxiliary variables -------------------------- */
	Eigen::Matrix3d R;
	Eigen::VectorXd e;
	/* -------------------------------------------------------------------------- */

	/* ------------------------ Variables initialization ------------------------ */
	R = rpy2rot(rpy);
	/* -------------------------------------------------------------------------- */

	/* ---------------------------------- Body ---------------------------------- */
	e = rot2quat(R);
	/* -------------------------------------------------------------------------- */
	return e;
}

Eigen::Vector3d quat2rpy(Eigen::VectorXd quat)
{
	/**================================================================================================
	 *                                         DESCRIPTION
	 * 
	 * Computes and returns the Eulers' angles associated with the passed-in unit quaternion.
	 *================================================================================================**/

	/* --------------------------- Auxiliary variables -------------------------- */
	Eigen::Matrix3d R;
	Eigen::Vector3d rpy;
	/* -------------------------------------------------------------------------- */

	/* ------------------------ Variables initialization ------------------------ */
	R = quat2rot(quat);
	/* -------------------------------------------------------------------------- */

	/* ---------------------------------- Body ---------------------------------- */
	rpy = rot2rpy_1(R);
	/* -------------------------------------------------------------------------- */

	return rpy;
}
/* -------------------------------------------------------------------------- */

/* -------------------------- RPY-2-ROT - ROT-2-RPY ------------------------- */
Eigen::Matrix3d rpy2rot(Eigen::Vector3d rpy)
{
	/**================================================================================================
	 *                                         DESCRIPTION
	 * 
	 * Computes and returns the rotation matrix associated with the passed-in Eulers' angles
	 *================================================================================================**/

	/* --------------------------- Auxiliary variables -------------------------- */
	double phi;
	double theta;
	double psi;

	double cp;
	double ct;
	double cf;

	double sp;
	double st;
	double sf;

	Eigen::Matrix3d R;
	/* -------------------------------------------------------------------------- */

	/* ------------------------ Variables initialization ------------------------ */
	phi = rpy[0];
	theta = rpy[1];
	psi = rpy[2];

	cp = cos(psi);
	ct = cos(theta);
	cf = cos(phi);

	sp = sin(psi);
	st = sin(theta);
	sf = sin(phi);
	/* -------------------------------------------------------------------------- */

	/* -------------------------------------------------------------------------- */
	/*                                 FIXED FRAME                                */
	/* -------------------------------------------------------------------------- */

	// /* -------------------------------- First row ------------------------------- */
	// R(0,0) = cf * ct;
	// R(0,1) = -sf * cp + cf * st * sp;
	// R(0,2) = sf* sp + cf * st * cp;
	// /* -------------------------------------------------------------------------- */

	// /* ------------------------------- Second row ------------------------------- */
	// R(1,0) = sf * ct;
	// R(1,1) = cf * cp + sf * st * sp;
	// R(1,2) = -cf * sp + sf * st * cp;
	// /* -------------------------------------------------------------------------- */

	// /* -------------------------------- Third row ------------------------------- */
	// R(2,0) = -st;
	// R(2,1) = ct * sp;
	// R(2,2) = ct * cp;
	// /* -------------------------------------------------------------------------- */

	/* -------------------------------------------------------------------------- */

	/* -------------------------------------------------------------------------- */
	/*                                CURRENT FRAME                               */
	/* -------------------------------------------------------------------------- */

	/* -------------------------------- First row ------------------------------- */
	R(0,0) = cp * ct;
	R(0,1) = -sp * cf + cp * st * sf;
	R(0,2) = sp* sf + cp * st * cf;
	/* -------------------------------------------------------------------------- */

	/* ------------------------------- Second row ------------------------------- */
	R(1,0) = sp * ct;
	R(1,1) = cp * cf + sp * st * sf;
	R(1,2) = -cp * sf + sp * st * cf;
	/* -------------------------------------------------------------------------- */

	/* -------------------------------- Third row ------------------------------- */
	R(2,0) = -st;
	R(2,1) = ct * sf;
	R(2,2) = ct * cf;
	/* -------------------------------------------------------------------------- */

	/* -------------------------------------------------------------------------- */

	return R;
}

Eigen::Vector3d rot2rpy_1(Eigen::Matrix3d R)
{
	/**================================================================================================
	 *                                         DESCRIPTION
	 * 
	 * Computes and returns the Eulers' angles associated with the passed-in rotation matrix.
	 *================================================================================================**/

	/* --------------------------- Auxiliary variables -------------------------- */
	Eigen::Vector3d rpy;
	double app;
	/* -------------------------------------------------------------------------- */
	
	/* ------------------------ Variables initialization ------------------------ */
	app = sqrt(pow(R(2,1),2) + pow(R(2,2),2));
	/* -------------------------------------------------------------------------- */

	/* ---------------------------------- Body ---------------------------------- */
	rpy(0) = atan2(R(1,0), R(0,0)); //phi (around z)
	rpy(1) = atan2(-R(2,0), app); //theta (around y)
	rpy(2) = atan2(R(2,1), R(2,2)); //psi (around x)

	std::swap(rpy(0),rpy(2)); // According to the convention, the first element of a 3D vector is related to the x-axis and the third to the z-axis. So, it is necessary a swap.
	/* -------------------------------------------------------------------------- */

	return rpy;
}

Eigen::Vector3d rot2rpy_2(Eigen::Matrix3d R)
{
	/**================================================================================================
	 *                                         DESCRIPTION
	 * 
	 * Computes and returns the Eulers' angles associated with the passed-in rotation matrix.
	 *================================================================================================**/

	/* --------------------------- Auxiliary variables -------------------------- */
	Eigen::Vector3d rpy;
	double app;
	/* -------------------------------------------------------------------------- */

	/* ------------------------ Variables initialization ------------------------ */
	app = sqrt(pow(R(2,1),2) + pow(R(2,2),2));
	/* -------------------------------------------------------------------------- */

	/* ---------------------------------- Body ---------------------------------- */
	rpy(0) = atan2(-R(1,0), -R(0,0)); //phi (around z)
	rpy(0) = atan2(-R(2,0), -app);  //theta (around y)
	rpy(0) = atan2(-R(2,1), -R(2,2)); //psi (around x)

	std::swap(rpy(0),rpy(2)); //According to the convention, the first element of a 3D vector is related to the x-axis and the third to the z-axis. So, it is necessary a swap.
	/* -------------------------------------------------------------------------- */

	return rpy;
}
/* -------------------------------------------------------------------------- */

/* ------------------- ROT-2-AXIS_ANGLE - AXIS_ANGLE-2-ROT ------------------ */
Eigen::VectorXd R2axis(Eigen::Matrix3d R)
{
	/**================================================================================================
	 *                                         DESCRIPTION
	 * 
	 * Computes and returns the axis-angle associated with the passed-in rotation matrix
	 *================================================================================================**/

	/* --------------------------- Auxiliary variables -------------------------- */
	Eigen::VectorXd axis(4);
	double sum;
	/* -------------------------------------------------------------------------- */

	/* ------------------------ Variables initialization ------------------------ */
	sum = (R(0,0) + R(1,1) + R(2,2) - 1)/2;
	/* -------------------------------------------------------------------------- */

	/* ---------------------------------- Body ---------------------------------- */
	
	/* ---------------------------------- Angle --------------------------------- */
	if(sum < -1)
		sum = -1;
	else if(sum > 1)
		sum = 1;
	
	axis(0) = acos(sum);
	/* -------------------------------------------------------------------------- */

	/* ---------------------------------- Axis ---------------------------------- */
	if(std::abs(axis(0)) <= 1e-6)
		axis << 0,0,0,1;
	else if(std::abs(axis(0) - PI) <= 1e-6)
	{
		axis(1) = std::sqrt((R(0,0) + 1)/2.0);
		axis(2) = std::sqrt((R(1,1) + 1)/2.0);
		axis(3) = std::sqrt((R(2,2) + 1)/2.0);
	}
	else
	{
		axis(1) = 1/(2*sin(axis(0))) * ( R(2,1) - R(1,2) );
		axis(2) = 1/(2*sin(axis(0))) * ( R(0,2) - R(2,0) );
		axis(3) = 1/(2*sin(axis(0))) * ( R(1,0) - R(0,1) );
	}
	/* -------------------------------------------------------------------------- */

	/* -------------------------------------------------------------------------- */
	
	return axis;
}

Eigen::Matrix3d axis2R(Eigen::Vector3d k, double theta)
{
	/**================================================================================================
	 *                                         DESCRIPTION
	 * 
	 * Computes and returns the rotation matrix associated with the passed-in axis-angle
	 *================================================================================================**/
	
	/* --------------------------- Auxiliary variables -------------------------- */
	double ct;
	double st;

	Eigen::Matrix3d R;
	/* -------------------------------------------------------------------------- */

	/* ------------------------ Variables initialization ------------------------ */
	ct = cos(theta);
	st = sin(theta);
	/* -------------------------------------------------------------------------- */

	/* ---------------------------------- Body ---------------------------------- */

	/* -------------------------------- First row ------------------------------- */
	R(0,0) = ( k(0)*k(0)*(1 - ct) ) + ct;
	R(0,1) = ( k(0)*k(1)*(1 - ct) ) - (k(2)*st);
	R(0,2) = ( k(0)*k(2)*(1 - ct) ) + (k(1)*st);
	/* -------------------------------------------------------------------------- */

	/* ------------------------------- Second row ------------------------------- */
	R(1,0) = ( k(0)*k(1)*(1 - ct) ) + (k(2)*st);
	R(1,1) = ( k(1)*k(1)*(1 - ct) ) + ct;
	R(1,2) = ( k(1)*k(2)*(1 - ct) ) - (k(0)*st);
	/* -------------------------------------------------------------------------- */

	/* -------------------------------- Third row ------------------------------- */
	R(2,0) = ( k(0)*k(2)*(1 - ct) ) - (k(1)*st);
	R(2,1) = ( k(1)*k(2)*(1 - ct) ) + (k(0)*st);
	R(2,2) = ( k(2)*k(2)*(1 - ct) ) + ct;
	/* -------------------------------------------------------------------------- */

	/* -------------------------------------------------------------------------- */

	return R;
}
/* -------------------------------------------------------------------------- */

/* -------------------------- Unit Quaternion Error ------------------------- */
Eigen::VectorXd quatError(Eigen::VectorXd ed, Eigen::VectorXd e)
{
	/**================================================================================================
	 *                                         DESCRIPTION
	 * 
	 * Computes and returns the orientation error vector associated with the passed-in unit quaternions
	 *================================================================================================**/

	/* --------------------------- Auxiliary variables -------------------------- */
	int i;

	Eigen::Vector3d ed_app;
	Eigen::Vector3d e_app;

	double eta_tilde;
	double angle;

	Eigen::Vector3d eo;
	/* -------------------------------------------------------------------------- */

	/* ------------------------ Variables initialization ------------------------ */
	i = 0;

	for(i=0; i<3; i++) {
		ed_app(i) = ed(i);
		e_app(i) = e(i);
	}
	/* -------------------------------------------------------------------------- */

	/* ---------------------------------- Body ---------------------------------- */
	eta_tilde = e(3)*ed(3) +e_app.transpose() * ed_app;
	eo = e(3)*ed_app - ed(3)*e_app - ed_app.cross(e_app);

	angle = atan2(eo.norm(), eta_tilde);

	if(angle > PI/2)
		eo = -eo;
	/* -------------------------------------------------------------------------- */

	return eo;
}
/* -------------------------------------------------------------------------- */

/* ---------------------------------- Sign ---------------------------------- */
int sign(double x)
{
	/* ---------------------------------- Body ---------------------------------- */
	if(x < 0)
		return -1;
	else
		return 1;
	/* -------------------------------------------------------------------------- */
}
/* -------------------------------------------------------------------------- */

/* ------------------ CONTACT-2-CONTROL - CONTROL-2-CONTACT ----------------- */
Eigen::Vector3d contact2control(Eigen::Vector3d contact_point_, double b_)
{
	/* -------------------------------------------------------------------------- */
	/*                             Auxiliary Variables                            */
	/* -------------------------------------------------------------------------- */
	Eigen::Vector3d control_point_;
	/* -------------------------------------------------------------------------- */

	/* -------------------------------------------------------------------------- */
	/*                          Variables Initialization                          */
	/* -------------------------------------------------------------------------- */

	/* -------------------------------------------------------------------------- */

	/* -------------------------------------------------------------------------- */
	/*                                 Processing                                 */
	/* -------------------------------------------------------------------------- */

	/* ------------------------------- Orientation ------------------------------ */
	control_point_[2] = contact_point_[2];
	/* -------------------------------------------------------------------------- */

	/* -------------------------------- Position -------------------------------- */
	control_point_[0] = contact_point_[0] + (b_*cos(contact_point_[2]));
	control_point_[1] = contact_point_[1] + (b_*sin(contact_point_[2]));
	/* -------------------------------------------------------------------------- */

	/* -------------------------------------------------------------------------- */
	/*                                   Return                                   */
	/* -------------------------------------------------------------------------- */
	return control_point_;
	/* -------------------------------------------------------------------------- */
}

Eigen::Vector3d control2contact(Eigen::Vector3d control_point_, double b_)
{
	/* -------------------------------------------------------------------------- */
	/*                             Auxiliary Variables                            */
	/* -------------------------------------------------------------------------- */
	Eigen::Vector3d contact_point_;
	/* -------------------------------------------------------------------------- */

	/* -------------------------------------------------------------------------- */
	/*                          Variables Initialization                          */
	/* -------------------------------------------------------------------------- */

	/* -------------------------------------------------------------------------- */

	/* -------------------------------------------------------------------------- */
	/*                                 Processing                                 */
	/* -------------------------------------------------------------------------- */

	/* ------------------------------- Orientation ------------------------------ */
	contact_point_[2] = control_point_[2];
	/* -------------------------------------------------------------------------- */

	/* -------------------------------- Position -------------------------------- */
	contact_point_[0] = control_point_[0] - (b_*cos(control_point_[2]));
	contact_point_[1] = control_point_[1] - (b_*sin(control_point_[2]));
	/* -------------------------------------------------------------------------- */

	/* -------------------------------------------------------------------------- */

	/* -------------------------------------------------------------------------- */
	/*                                   Return                                   */
	/* -------------------------------------------------------------------------- */
	return contact_point_;
	/* -------------------------------------------------------------------------- */
}
/* -------------------------------------------------------------------------- */

/* -------------------------------------------------------------------------- */
