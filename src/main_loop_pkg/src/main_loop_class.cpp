/* -------------------------------------------------------------------------- */
/*                                INCLUDE FILES                               */
/* -------------------------------------------------------------------------- */

/* ----------------------------------- ROS ---------------------------------- */
#include "main_loop_pkg/main_loop_class.h"
/* -------------------------------------------------------------------------- */

/* -------------------------------------------------------------------------- */

/* -------------------------------------------------------------------------- */
/*                         Constructors and Destructor                        */
/* -------------------------------------------------------------------------- */
MainLoopClass::MainLoopClass(const ros::NodeHandle &node_handler_)
{
    /* -------------------------------------------------------------------------- */
    /*                             Auxiliary Variables                            */
    /* -------------------------------------------------------------------------- */
    
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                          Variables Initialization                          */
    /* -------------------------------------------------------------------------- */
    
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                                 Processing                                 */
    /* -------------------------------------------------------------------------- */

    /* --------------------------- Control Attributes --------------------------- */
    this->node_handler.getParam("/simulation",this->simulation);
    this->node_handler.getParam("/timer/external",this->external_timer.first);
    this->external_timer.second = false;

    this->control_frequency = 50;
    this->Ts = 1/this->control_frequency;
    this->t = 0.0;
    /* -------------------------------------------------------------------------- */

    /* ------------------------- Initialization Methods ------------------------- */
    this->init_humans_parameters();
    this->init_robots_parameters();
    this->init_publishers_and_subscribers();
    // /* -------------------------------------------------------------------------- */

    // /* ----------------------------- Periodic Timer ----------------------------- */
    this->periodic_timer = this->node_handler.createTimer(ros::Duration(this->Ts),&MainLoopClass::init_timer_callback,this,false,true);
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
}

MainLoopClass::~MainLoopClass(){}
/* -------------------------------------------------------------------------- */

/* -------------------------------------------------------------------------- */
/*                           Initialization Methods                           */
/* -------------------------------------------------------------------------- */
void MainLoopClass::init_humans_parameters()
{
    /* -------------------------------------------------------------------------- */
    /*                             Auxiliary Variables                            */
    /* -------------------------------------------------------------------------- */
    XmlRpc::XmlRpcValue humans_parameters;
    std::pair<bool,bool> check_result;
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                          Variables Initialization                          */
    /* -------------------------------------------------------------------------- */
    this->node_handler.getParam("/humans/position",humans_parameters);
    check_result = std::make_pair<bool,bool>(false,false);
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                                 Processing                                 */
    /* -------------------------------------------------------------------------- */
    for(int i = 0; i < humans_parameters.size(); i++)
    {
        /* --------------------------- Auxiliary Variable --------------------------- */
        Eigen::Vector2d position;
        /* -------------------------------------------------------------------------- */

        /* ----------------------------- X - Coordinate ----------------------------- */
        if(humans_parameters[i][0].getType() == XmlRpc::XmlRpcValue::TypeDouble)
        {
            /* --------------------------------- Casting -------------------------------- */
            position(0) = (double) humans_parameters[i][0];
            /* -------------------------------------------------------------------------- */

            /* ------------------------------ Check Result ------------------------------ */
            check_result.first = true;
            /* -------------------------------------------------------------------------- */
        }
        else if(humans_parameters[i][0].getType() == XmlRpc::XmlRpcValue::TypeInt)
        {
            /* --------------------------------- Casting -------------------------------- */
            position(0) = (int) humans_parameters[i][0];
            /* -------------------------------------------------------------------------- */

            /* ------------------------------ Check Result ------------------------------ */
            check_result.first = true;
            /* -------------------------------------------------------------------------- */
        }
        /* -------------------------------------------------------------------------- */

        /* ----------------------------- Y - Coordinate ----------------------------- */
        if(humans_parameters[i][1].getType() == XmlRpc::XmlRpcValue::TypeDouble)
        {
            /* --------------------------------- Casting -------------------------------- */
            position(1) = (double) humans_parameters[i][1];
            /* -------------------------------------------------------------------------- */

            /* ------------------------------ Check Result ------------------------------ */
            check_result.second = true;
            /* -------------------------------------------------------------------------- */
        }
        else if(humans_parameters[i][1].getType() == XmlRpc::XmlRpcValue::TypeInt)
        {
            /* --------------------------------- Casting -------------------------------- */
            position(1) = (int) humans_parameters[i][1];
            /* -------------------------------------------------------------------------- */

            /* ------------------------------ Check Result ------------------------------ */
            check_result.second = true;
            /* -------------------------------------------------------------------------- */
        }
        /* -------------------------------------------------------------------------- */

        /* -------------------------------- Push Back ------------------------------- */
        if(check_result.first && check_result.second)
            this->humans_positions_vector.push_back(position);
        /* -------------------------------------------------------------------------- */
    }
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                              Number of Humans                              */
    /* -------------------------------------------------------------------------- */
    this->number_of_humans = this->humans_positions_vector.size();
    /* -------------------------------------------------------------------------- */
}

void MainLoopClass::init_robots_parameters()
{
    /* -------------------------------------------------------------------------- */
    /*                             Auxiliary Variables                            */
    /* -------------------------------------------------------------------------- */
    XmlRpc::XmlRpcValue robots_parameters;
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                          Variables Initialization                          */
    /* -------------------------------------------------------------------------- */
    this->node_handler.getParam("/robots/home_position",robots_parameters);
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                                 Processing                                 */
    /* -------------------------------------------------------------------------- */
    for(int i = 0; i < robots_parameters.size(); i++)
    {
        /* --------------------------- Auxiliary Variable --------------------------- */
        Eigen::Vector2d position;
        std::pair<bool,bool> check_result(false,false);
        /* -------------------------------------------------------------------------- */

        /* ----------------------------- X - Coordinate ----------------------------- */
        if(robots_parameters[i][0].getType() == XmlRpc::XmlRpcValue::TypeDouble)
        {
            /* --------------------------------- Casting -------------------------------- */
            position(0) = (double) robots_parameters[i][0];
            /* -------------------------------------------------------------------------- */

            /* ------------------------------ Check Result ------------------------------ */
            check_result.first = true;
            /* -------------------------------------------------------------------------- */
        }
        else if(robots_parameters[i][0].getType() == XmlRpc::XmlRpcValue::TypeInt)
        {
            /* --------------------------------- Casting -------------------------------- */
            position(0) = (int) robots_parameters[i][0];
            /* -------------------------------------------------------------------------- */

            /* ------------------------------ Check Result ------------------------------ */
            check_result.first = true;
            /* -------------------------------------------------------------------------- */
        }
        /* -------------------------------------------------------------------------- */

        /* ----------------------------- Y - Coordinate ----------------------------- */
        if(robots_parameters[i][1].getType() == XmlRpc::XmlRpcValue::TypeDouble)
        {
            /* --------------------------------- Casting -------------------------------- */
            position(1) = (double) robots_parameters[i][1];
            /* -------------------------------------------------------------------------- */

            /* ------------------------------ Check Result ------------------------------ */
            check_result.second = true;
            /* -------------------------------------------------------------------------- */
        }
        else if(robots_parameters[i][1].getType() == XmlRpc::XmlRpcValue::TypeInt)
        {
            /* --------------------------------- Casting -------------------------------- */
            position(1) = (int) robots_parameters[i][1];
            /* -------------------------------------------------------------------------- */

            /* ------------------------------ Check Result ------------------------------ */
            check_result.second = true;
            /* -------------------------------------------------------------------------- */
        }
        /* -------------------------------------------------------------------------- */

        /* -------------------------------- Push Back ------------------------------- */
        if(check_result.first && check_result.second)
            this->home_configurations_vector.push_back(position);
        /* -------------------------------------------------------------------------- */
    }
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                              Number of Robots                              */
    /* -------------------------------------------------------------------------- */
    this->number_of_robots = this->home_configurations_vector.size();
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                              Objects Creation                              */
    /* -------------------------------------------------------------------------- */
    for(int i = 0; i < this->number_of_robots; i++)
    {

        /* -------------------------------- Creation -------------------------------- */
        RobotControllerClass robot(fmt::format("diff_drive_robot",i+1) /*Name*/, i+1 /*ID*/, this->home_configurations_vector[i] /*Home Position*/);
        /* -------------------------------------------------------------------------- */

        /* -------------------------------- Push Back ------------------------------- */
        this->robots_vector.push_back(robot);
        /* -------------------------------------------------------------------------- */
    }
    /* -------------------------------------------------------------------------- */
}

void MainLoopClass::init_controllers_parameters()
{
    /* -------------------------------------------------------------------------- */
    /*                             Auxiliary Variables                            */
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                          Variables Initialization                          */
    /* -------------------------------------------------------------------------- */
    this->node_handler.getParam("/robots/controller/b",this->b);
    this->node_handler.getParam("/robots/controller/distance_threshold",this->distance_threshold);
    this->node_handler.getParam("/robots/controller/obstacle_avoidance_enabled",this->obstacle_avoidance_enabled);
    this->node_handler.getParam("/robots/controller/obstacle_avoidance_threshold",this->obstacle_avoidance_threshold);
    this->node_handler.getParam("/robots/controller/obstacle_avoidance_gain",this->obstacle_avoidance_gain);
    this->node_handler.getParam("/robots/controller/obstacle_avoidance_eta",this->obstacle_avoidance_eta);
    this->node_handler.getParam("/robots/controller/k_1",this->k_1);
    this->node_handler.getParam("/robots/controller/k_2",this->k_2);
    this->node_handler.getParam("/robots/controller/k_3",this->k_3);
    this->node_handler.getParam("/robots/controller/max_linear_velocity",this->max_linear_velocity);
    this->node_handler.getParam("/robots/controller/max_angular_velocity",this->max_angular_velocity);
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                                 Processing                                 */
    /* -------------------------------------------------------------------------- */
    for(int i = 0; i < this->number_of_robots; i++)
        /* ----------------------------- Initialization ----------------------------- */
        this->robots_vector[i].init_robot_controller_parameters(this->b,this->distance_threshold,this->k_1,this->k_2,this->k_3,this->max_linear_velocity,this->max_angular_velocity,this->obstacle_avoidance_enabled,this->obstacle_avoidance_gain,this->obstacle_avoidance_threshold,this->obstacle_avoidance_eta);
        /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
}

void MainLoopClass::init_publishers_and_subscribers()
{
    /* -------------------------------------------------------------------------- */
    /*                             Auxiliary Variables                            */
    /* -------------------------------------------------------------------------- */
    std::vector<std::string> odometry_topics;
    XmlRpc::XmlRpcValue velocities_topics;
    XmlRpc::XmlRpcValue MILP_results_topics;

    ros::Publisher ros_publisher_obj;
    ros::Subscriber ros_subscriber_obj;
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                          Variables Initialization                          */
    /* -------------------------------------------------------------------------- */
    this->node_handler.getParam("/robots/topics/odometry",odometry_topics);
    this->node_handler.getParam("/robots/topics/velocities",velocities_topics);
    this->node_handler.getParam("/robots/topics/MILP_results",MILP_results_topics);
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                                 Subscribers                                */
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                                    Time                                    */
    /* -------------------------------------------------------------------------- */
    if(this->external_timer.first)
    {
        /* --------------------------- Auxiliary Variable --------------------------- */
        XmlRpc::XmlRpcValue timer_topic;
        /* -------------------------------------------------------------------------- */

        /* ----------------------------------- Get ---------------------------------- */
        this->node_handler.getParam("/timer/topic",timer_topic);
        /* -------------------------------------------------------------------------- */

        /* -------------------------------- Creation -------------------------------- */
        this->timing_SUB = this->node_handler.subscribe((std::string) timer_topic,1,&MainLoopClass::time_update,this);
        /* -------------------------------------------------------------------------- */
    }
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                                   Robots                                   */
    /* -------------------------------------------------------------------------- */
    for(int i = 0; i < this->number_of_robots; i++)
    {
        /* -------------------------------------------------------------------------- */
        /*                                  Odometry                                  */
        /* -------------------------------------------------------------------------- */

        /* -------------------------------- Creation -------------------------------- */
        if(this->simulation)
            ros_subscriber_obj = this->node_handler.subscribe<nav_msgs::Odometry>(odometry_topics[i],1,boost::bind(&MainLoopClass::odometry_subscriber_simulation_CB,this,_1,i+1));
        else
            ros_subscriber_obj = this->node_handler.subscribe<geometry_msgs::PoseStamped>(odometry_topics[i],1,boost::bind(&MainLoopClass::odometry_subscriber_real_CB,this,_1,i+1));
        /* -------------------------------------------------------------------------- */

        /* -------------------------------- Push Back ------------------------------- */
        this->odometry_SUBs.push_back(ros_subscriber_obj);
        /* -------------------------------------------------------------------------- */

        /* -------------------------------------------------------------------------- */
        /*                                MILP Results                                */
        /* -------------------------------------------------------------------------- */

        /* -------------------------------- Creation -------------------------------- */
        ros_subscriber_obj = this->node_handler.subscribe<diff_drive_robot::MILPResult>(MILP_results_topics[i],1,boost::bind(&MainLoopClass::MILP_results_subscriber_CB,this,_1,i+1));
        /* -------------------------------------------------------------------------- */

        /* -------------------------------- Push Back ------------------------------- */
        this->MILP_results_SUBs.push_back(ros_subscriber_obj);
        /* -------------------------------------------------------------------------- */

        /* -------------------------------------------------------------------------- */
    }
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                                 Publishers                                 */
    /* -------------------------------------------------------------------------- */
    for(int i = 0; i < this->number_of_robots; i++)
    {
        /* -------------------------------------------------------------------------- */
        /*                                 Velocities                                 */
        /* -------------------------------------------------------------------------- */

        /* -------------------------------- Creation -------------------------------- */
        ros_publisher_obj = this->node_handler.advertise<geometry_msgs::Twist>(velocities_topics[i],1);
        /* -------------------------------------------------------------------------- */

        /* -------------------------------- Push Back ------------------------------- */
        this->robots_velocities_PUBs.push_back(ros_publisher_obj);
        /* -------------------------------------------------------------------------- */

        /* -------------------------------- Creation -------------------------------- */
        ros_publisher_obj = this->node_handler.advertise<geometry_msgs::Twist>(fmt::format("/robot{}/control_point_velocity",i+1),1);
        /* -------------------------------------------------------------------------- */

        /* -------------------------------- Push Back ------------------------------- */
        this->control_points_velocity_PUBs.push_back(ros_publisher_obj);
        /* -------------------------------------------------------------------------- */

        /* -------------------------------- Creation -------------------------------- */
        ros_publisher_obj = this->node_handler.advertise<geometry_msgs::Twist>(fmt::format("/robot{}/desired_control_point_velocity",i+1),1);
        /* -------------------------------------------------------------------------- */

        /* -------------------------------- Push Back ------------------------------- */
        this->desired_control_points_velocity_PUBs.push_back(ros_publisher_obj);
        /* -------------------------------------------------------------------------- */

        /* -------------------------------- Creation -------------------------------- */
        ros_publisher_obj = this->node_handler.advertise<geometry_msgs::Twist>(fmt::format("/robot{}/avoidance_velocities",i+1),1);
        /* -------------------------------------------------------------------------- */

        /* -------------------------------- Push Back ------------------------------- */
        this->avoidance_velocity_offsets_PUBs.push_back(ros_publisher_obj);
        /* -------------------------------------------------------------------------- */

        /* -------------------------------------------------------------------------- */

        /* -------------------------------------------------------------------------- */
        /*                          Position and Orientation                          */
        /* -------------------------------------------------------------------------- */

        /* -------------------------------- Creation -------------------------------- */
        ros_publisher_obj = this->node_handler.advertise<geometry_msgs::PointStamped>(fmt::format("/robot{}/pose",i+1),1);
        /* -------------------------------------------------------------------------- */

        /* -------------------------------- Push Back ------------------------------- */
        this->control_points_pose_PUBs.push_back(ros_publisher_obj);
        /* -------------------------------------------------------------------------- */

        /* -------------------------------------------------------------------------- */

        /* -------------------------------------------------------------------------- */
        /*                      Desired Position and Orientation                      */
        /* -------------------------------------------------------------------------- */

        /* -------------------------------- Creation -------------------------------- */
        ros_publisher_obj = this->node_handler.advertise<geometry_msgs::PointStamped>(fmt::format("/robot{}/desired_pose",i+1),1);
        /* -------------------------------------------------------------------------- */

        /* -------------------------------- Push Back ------------------------------- */
        this->desired_control_points_pose_PUBs.push_back(ros_publisher_obj);
        /* -------------------------------------------------------------------------- */

        /* -------------------------------------------------------------------------- */

        /* -------------------------------------------------------------------------- */
        /*                              Ongoing Activity                              */
        /* -------------------------------------------------------------------------- */

        /* -------------------------------- Creation -------------------------------- */
        ros_publisher_obj = this->node_handler.advertise<diff_drive_robot::MILPResult>(fmt::format("/robot{}/rosout/ongoing_activity",i+1),1);
        /* -------------------------------------------------------------------------- */

        /* -------------------------------- Push Back ------------------------------- */
        this->robots_ongoing_activity_PUBs.push_back(ros_publisher_obj);
        /* -------------------------------------------------------------------------- */

        /* -------------------------------------------------------------------------- */

        /* -------------------------------------------------------------------------- */
    }
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
}
/* -------------------------------------------------------------------------- */

/* -------------------------------------------------------------------------- */
/*                                  Messages                                  */
/* -------------------------------------------------------------------------- */
void MainLoopClass::publish_robots_velocities()
{
    /* -------------------------------------------------------------------------- */
    /*                             Auxiliary Variables                            */
    /* -------------------------------------------------------------------------- */
    geometry_msgs::Twist twist_msg;
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                          Variables Initialization                          */
    /* -------------------------------------------------------------------------- */
    twist_msg.linear.y = 0.0;
    twist_msg.linear.z = 0.0;

    twist_msg.angular.x = 0.0;
    twist_msg.angular.y = 0.0;
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                                 Processing                                 */
    /* -------------------------------------------------------------------------- */
    for(int i = 0; i < this->number_of_robots; i++)
    {
        /* --------------------------------- Filling -------------------------------- */
        twist_msg.linear.x = this->robots_vector[i].get_linear_velocity(); 
        twist_msg.angular.z = this->robots_vector[i].get_angular_velocity();
        /* -------------------------------------------------------------------------- */

        /* ------------------------------- Publishing ------------------------------- */
        this->robots_velocities_PUBs[i].publish(twist_msg);
        /* -------------------------------------------------------------------------- */
    }
    /* -------------------------------------------------------------------------- */
}

void MainLoopClass::publish_avoidance_velocity_offsets()
{
    /* -------------------------------------------------------------------------- */
    /*                             Auxiliary Variables                            */
    /* -------------------------------------------------------------------------- */
    geometry_msgs::Twist twist_msg;
    Eigen::Vector2d velocities;
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                          Variables Initialization                          */
    /* -------------------------------------------------------------------------- */
    twist_msg.linear.z = 0.0;

    twist_msg.angular.x = 0.0;
    twist_msg.angular.y = 0.0;
    twist_msg.angular.z = 0.0;
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                                 Processing                                 */
    /* -------------------------------------------------------------------------- */
    for(int i = 0; i < this->number_of_robots; i++)
    {
        /* ----------------------------------- Get ---------------------------------- */
        velocities = this->robots_vector[i].get_avoidance_velocity_offsets();
        /* -------------------------------------------------------------------------- */

        /* --------------------------------- Filling -------------------------------- */
        twist_msg.linear.x = velocities(0);
        twist_msg.linear.y = velocities(1);
        /* -------------------------------------------------------------------------- */

        /* ------------------------------- Publishing ------------------------------- */
        this->avoidance_velocity_offsets_PUBs[i].publish(twist_msg);
        /* -------------------------------------------------------------------------- */
    }
    /* -------------------------------------------------------------------------- */
}

void MainLoopClass::publish_control_points_poses()
{
    /* -------------------------------------------------------------------------- */
    /*                             Auxiliary Variables                            */
    /* -------------------------------------------------------------------------- */
    geometry_msgs::PointStamped point_msg;
    Eigen::Vector2d position;
    double theta;
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                          Variables Initialization                          */
    /* -------------------------------------------------------------------------- */
    point_msg.header.stamp = ros::Time::now();
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                                 Processing                                 */
    /* -------------------------------------------------------------------------- */
    for(int i = 0; i < this->number_of_robots; i++)
    {
        /* -------------------------------------------------------------------------- */
        /*                                Current Pose                                */
        /* -------------------------------------------------------------------------- */

        /* ----------------------------------- Get ---------------------------------- */
        position = this->robots_vector[i].get_control_point_position();
        theta = this->robots_vector[i].get_orientation();
        /* -------------------------------------------------------------------------- */

        /* --------------------------------- Filling -------------------------------- */
        point_msg.point.x = position(0);
        point_msg.point.y = position(1);
        point_msg.point.z = theta;
        /* -------------------------------------------------------------------------- */

        /* ------------------------------- Publishing ------------------------------- */
        this->control_points_pose_PUBs[i].publish(point_msg);
        /* -------------------------------------------------------------------------- */

        /* -------------------------------------------------------------------------- */

        /* -------------------------------------------------------------------------- */
        /*                                Desired Pose                                */
        /* -------------------------------------------------------------------------- */

        /* ----------------------------------- Get ---------------------------------- */
        position = this->robots_vector[i].get_desired_control_point_position();
        theta = this->robots_vector[i].get_orientation();
        /* -------------------------------------------------------------------------- */

        /* --------------------------------- Filling -------------------------------- */
        point_msg.point.x = position(0);
        point_msg.point.y = position(1);
        point_msg.point.z = theta;
        /* -------------------------------------------------------------------------- */

        /* ------------------------------- Publishing ------------------------------- */
        this->desired_control_points_pose_PUBs[i].publish(point_msg);
        /* -------------------------------------------------------------------------- */

        /* -------------------------------------------------------------------------- */
    }
    /* -------------------------------------------------------------------------- */
}

void MainLoopClass::publish_control_points_velocities()
{
    /* -------------------------------------------------------------------------- */
    /*                             Auxiliary Variables                            */
    /* -------------------------------------------------------------------------- */
    geometry_msgs::Twist twist_msg;
    Eigen::Vector2d velocities;
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                          Variables Initialization                          */
    /* -------------------------------------------------------------------------- */
    twist_msg.linear.z = 0.0;

    twist_msg.angular.x = 0.0;
    twist_msg.angular.y = 0.0;
    twist_msg.angular.z = 0.0;
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                                 Processing                                 */
    /* -------------------------------------------------------------------------- */
    for(int i = 0; i < this->number_of_robots; i++)
    {
        /* -------------------------------------------------------------------------- */
        /*                                  Velocity                                  */
        /* -------------------------------------------------------------------------- */

        /* ----------------------------------- Get ---------------------------------- */
        velocities = this->robots_vector[i].get_control_point_velocity();
        /* -------------------------------------------------------------------------- */

        /* --------------------------------- Filling -------------------------------- */
        twist_msg.linear.x = velocities(0); 
        twist_msg.linear.y = velocities(1);
        /* -------------------------------------------------------------------------- */

        /* ------------------------------- Publishing ------------------------------- */
        this->control_points_velocity_PUBs[i].publish(twist_msg);
        /* -------------------------------------------------------------------------- */

        /* -------------------------------------------------------------------------- */

        /* -------------------------------------------------------------------------- */
        /*                              Desired Velocity                              */
        /* -------------------------------------------------------------------------- */

        /* ----------------------------------- Get ---------------------------------- */
        velocities = this->robots_vector[i].get_desired_control_point_velocity();
        /* -------------------------------------------------------------------------- */

        /* --------------------------------- Filling -------------------------------- */
        twist_msg.linear.x = velocities(0); 
        twist_msg.linear.y = velocities(1);
        /* -------------------------------------------------------------------------- */

        /* ------------------------------- Publishing ------------------------------- */
        this->desired_control_points_velocity_PUBs[i].publish(twist_msg);
        /* -------------------------------------------------------------------------- */

        /* -------------------------------------------------------------------------- */
    }
    /* -------------------------------------------------------------------------- */
}

void MainLoopClass::publish_robots_ongoing_activity()
{
    /* -------------------------------------------------------------------------- */
    /*                             Auxiliary Variables                            */
    /* -------------------------------------------------------------------------- */
    ongoingActivityStruct ongoing_activity_;
    diff_drive_robot::MILPResult activity_msg_;
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                          Variables Initialization                          */
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                                 Processing                                 */
    /* -------------------------------------------------------------------------- */
    for(int i = 0; i < this->number_of_robots; i++)
    {
        /* ----------------------------------- Get ---------------------------------- */
        ongoing_activity_ = this->robots_vector[i].get_ongoing_activity();
        /* -------------------------------------------------------------------------- */

        /* ---------------------------- Check and Filling --------------------------- */
        if(ongoing_activity_.activity.phase.size() > 0)
        {
            /* -------------------------------- Robot ID -------------------------------- */
            activity_msg_.RobotID = i+1;
            /* -------------------------------------------------------------------------- */

            /* -------------------------------- Human ID -------------------------------- */
            for(int j = 0; j < this->humans_positions_vector.size(); j++)
            {
                /* ---------------------------------- Check --------------------------------- */
                if(ongoing_activity_.activity.phase[0].desired_configuration.head(2) == this->humans_positions_vector[j])
                {
                    /* -------------------------------- Push Back ------------------------------- */
                    activity_msg_.Humans.push_back(j+1);
                    /* -------------------------------------------------------------------------- */

                    /* ---------------------------------- Break --------------------------------- */
                    break;
                    /* -------------------------------------------------------------------------- */
                }
                /* -------------------------------------------------------------------------- */
            }
            /* -------------------------------------------------------------------------- */

            /* ------------------------------- Going Phase ------------------------------ */
            activity_msg_.GoingStart.push_back(ongoing_activity_.activity.nominal_start_time);
            activity_msg_.GoingFinish.push_back(activity_msg_.GoingStart[0] + ongoing_activity_.activity.phase[0].allocated_time);
            /* -------------------------------------------------------------------------- */

            /* ------------------------------ Waiting Phase ----------------------------- */
            activity_msg_.WaitingStart.push_back(activity_msg_.GoingFinish[0]);
            activity_msg_.WaitingFinish.push_back(activity_msg_.WaitingStart[0] + ongoing_activity_.activity.phase[1].allocated_time);
            /* -------------------------------------------------------------------------- */

            /* ------------------------------ Serving Phase ----------------------------- */
            activity_msg_.ServingStart.push_back(activity_msg_.WaitingFinish[0]);
            activity_msg_.ServingFinish.push_back(activity_msg_.ServingStart[0] + ongoing_activity_.activity.phase[2].allocated_time);
            /* -------------------------------------------------------------------------- */

            /* ------------------------------- Depot Phase ------------------------------ */
            activity_msg_.DepotStart.push_back(activity_msg_.ServingFinish[0]);
            activity_msg_.DepotFinish.push_back(activity_msg_.DepotStart[0] + ongoing_activity_.activity.phase[3].allocated_time);
            /* -------------------------------------------------------------------------- */
        }
        /* -------------------------------------------------------------------------- */

        /* ------------------------------- Publishing ------------------------------- */
        this->robots_ongoing_activity_PUBs[i].publish(activity_msg_);
        /* -------------------------------------------------------------------------- */
    }
    /* -------------------------------------------------------------------------- */
}
/* -------------------------------------------------------------------------- */

/* -------------------------------------------------------------------------- */
/*                           Periodic Time Callbacks                          */
/* -------------------------------------------------------------------------- */
void MainLoopClass::init_timer_callback(const ros::TimerEvent &event)
{
    /* -------------------------------------------------------------------------- */
    /*                             Auxiliary Variables                            */
    /* -------------------------------------------------------------------------- */
    bool odometry_state;
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                          Variables Initialization                          */
    /* -------------------------------------------------------------------------- */
    odometry_state = true;
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                              Robots Parameters                             */
    /* -------------------------------------------------------------------------- */

    /* ------------------- Overall State of the Odometry - Get ------------------ */
    for(int i = 0; i < this->number_of_robots; i++)
        odometry_state = odometry_state*this->robots_vector[i].get_odometry_state();
    /* -------------------------------------------------------------------------- */

    /* ------------------ Overall State of the Odometry - Check ----------------- */
    if(!odometry_state)
        return;
    /* -------------------------------------------------------------------------- */

    /* ----------------------------- Initialization ----------------------------- */
    this->init_controllers_parameters();
    /* -------------------------------------------------------------------------- */

    /* ---------------------------------- Debug --------------------------------- */
    std::cout << "Robots Parameters, Initialized!" << std::endl;
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                                    Timer                                   */
    /* -------------------------------------------------------------------------- */
    this->periodic_timer = this->node_handler.createTimer(ros::Duration(this->Ts),&MainLoopClass::periodic_timer_callback,this,false,true);
    /* -------------------------------------------------------------------------- */
}

void MainLoopClass::periodic_timer_callback(const ros::TimerEvent &event)
{
    /* -------------------------------------------------------------------------- */
    /*                                    Check                                   */
    /* -------------------------------------------------------------------------- */
    if(this->external_timer.first && !this->external_timer.second)
        return;
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                                 i-th Robot                                 */
    /* -------------------------------------------------------------------------- */
    for(int i = 0; i < this->number_of_robots; i++)
    {
        /* -------------------------------------------------------------------------- */
        /*                             Auxiliary Variables                            */
        /* -------------------------------------------------------------------------- */
        std::vector<Eigen::Vector2d> obstacles_position_;
        Eigen::Vector2d obstacle_position;
        /* -------------------------------------------------------------------------- */

        /* -------------------------------------------------------------------------- */
        /*                             Obstacles Position                             */
        /* -------------------------------------------------------------------------- */
        for(int j = 0; j < this->number_of_robots; j++)
        {
            /* ---------------------------------- Check --------------------------------- */
            if(i != j)
            {
                /* -------------------------------- Position -------------------------------- */
                obstacle_position = this->robots_vector[j].get_control_point_position();
                /* -------------------------------------------------------------------------- */

                /* -------------------------------- Push Back ------------------------------- */
                obstacles_position_.push_back(obstacle_position);
                /* -------------------------------------------------------------------------- */
            }
            /* -------------------------------------------------------------------------- */

            /* ----------------------- Is this the last iteration? ---------------------- */
            if(j == this->number_of_robots - 1)
                this->robots_vector[i].update_obstacles_position(obstacles_position_);
            /* -------------------------------------------------------------------------- */
        }
        /* -------------------------------------------------------------------------- */

        /* -------------------------------------------------------------------------- */
        /*                              Robot Parameters                              */
        /* -------------------------------------------------------------------------- */
        this->robots_vector[i].update_robot_parameters(this->t);
        /* -------------------------------------------------------------------------- */
    }
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                                ROS Messages                                */
    /* -------------------------------------------------------------------------- */
    this->publish_control_points_poses();
    this->publish_robots_velocities();
    this->publish_control_points_velocities();
    this->publish_robots_ongoing_activity();
    if(this->obstacle_avoidance_enabled)
        this->publish_avoidance_velocity_offsets();
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                                    Time                                    */
    /* -------------------------------------------------------------------------- */
    if(!this->external_timer.first)
        this->t = this->t + Ts;
    /* -------------------------------------------------------------------------- */
}
/* -------------------------------------------------------------------------- */

/* -------------------------------------------------------------------------- */
/*                             Callback Functions                             */
/* -------------------------------------------------------------------------- */
void MainLoopClass::time_update(const std_msgs::Float64::ConstPtr &msg)
{
    /* -------------------------------------------------------------------------- */
    /*                             Auxiliary Variables                            */
    /* -------------------------------------------------------------------------- */
    
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                          Variables Initialization                          */
    /* -------------------------------------------------------------------------- */
    
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                                 Processing                                 */
    /* -------------------------------------------------------------------------- */

    /* --------------------------------- Update --------------------------------- */
    this->t = msg->data;
    /* -------------------------------------------------------------------------- */

    /* ------------------------------- First Call ------------------------------- */
    if(!this->external_timer.second)
    {
        /* --------------------------------- Update --------------------------------- */
        this->external_timer.second = true;
        /* -------------------------------------------------------------------------- */

        /* ------------------------------ Debug Message ----------------------------- */
        std::cout << fmt::format("[{}]: Timer Initialized!",this->t) << std::endl;
        /* -------------------------------------------------------------------------- */
    }
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
}

void MainLoopClass::odometry_subscriber_simulation_CB(const nav_msgs::Odometry::ConstPtr &msg, int robot_ID)
{
    /* -------------------------------------------------------------------------- */
    /*                             Auxiliary Variables                            */
    /* -------------------------------------------------------------------------- */
    Eigen::Vector2d position;
    Eigen::Vector4d quat;

    double theta;
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                          Variables Initialization                          */
    /* -------------------------------------------------------------------------- */
    position << msg->pose.pose.position.x,msg->pose.pose.position.y;

    quat << msg->pose.pose.orientation.x,msg->pose.pose.orientation.y,msg->pose.pose.orientation.z,msg->pose.pose.orientation.w;
    theta = quat2rpy((Eigen::VectorXd) quat)(2);
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                                 Processing                                 */
    /* -------------------------------------------------------------------------- */

    /* ----------------------------------- Set ---------------------------------- */
    this->robots_vector[robot_ID-1].set_pose(position, theta);
    /* -------------------------------------------------------------------------- */

    /* ---------------------------------- Check --------------------------------- */
    if(!this->robots_vector[robot_ID-1].get_odometry_state())
        this->robots_vector[robot_ID-1].set_odometry_state(true);
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
}

void MainLoopClass::odometry_subscriber_real_CB(const geometry_msgs::PoseStamped::ConstPtr &msg, int robot_ID)
{
    /* -------------------------------------------------------------------------- */
    /*                             Auxiliary Variables                            */
    /* -------------------------------------------------------------------------- */
    Eigen::Vector2d position;
    Eigen::Vector4d quat;

    double theta;
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                          Variables Initialization                          */
    /* -------------------------------------------------------------------------- */
    position << msg->pose.position.x,msg->pose.position.y;

    quat << msg->pose.orientation.x,msg->pose.orientation.y,msg->pose.orientation.z,msg->pose.orientation.w;
    theta = quat2rpy((Eigen::VectorXd) quat)(2);
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                                 Processing                                 */
    /* -------------------------------------------------------------------------- */

    /* ----------------------------------- Set ---------------------------------- */
    this->robots_vector[robot_ID-1].set_pose(position, theta);
    /* -------------------------------------------------------------------------- */

    /* ---------------------------------- Check --------------------------------- */
    if(!this->robots_vector[robot_ID-1].get_odometry_state())
        this->robots_vector[robot_ID-1].set_odometry_state(true);
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
}

void MainLoopClass::MILP_results_subscriber_CB(const diff_drive_robot::MILPResult::ConstPtr &msg, int robot_ID)
{
    /* -------------------------------------------------------------------------- */
    /*                                    Check                                   */
    /* -------------------------------------------------------------------------- */
    if(msg->RobotID == 0 || msg->Humans.empty() || msg->GoingStart.empty() || msg->GoingFinish.empty() || msg->WaitingStart.empty() || msg->WaitingFinish.empty() || msg->ServingStart.empty() || msg->ServingFinish.empty() || msg->DepotStart.empty() || msg->DepotFinish.empty())
    {
        /* --------------------------------- Message -------------------------------- */
        std::cout << fmt::format("[{}][Robot-{}] An empty plan has just been received!",this->t,robot_ID)<<std::endl;
        /* -------------------------------------------------------------------------- */

        /* --------------------------------- Return --------------------------------- */
        return;
        /* -------------------------------------------------------------------------- */
    }
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                             Auxiliary Variables                            */
    /* -------------------------------------------------------------------------- */
    std::vector<activityStruct> activities_vector_;
    double k_1;
    double k_2;
    double k_3;
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                          Variables Initialization                          */
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                               Plan - Creation                              */
    /* -------------------------------------------------------------------------- */
    for(int i = 0; i < msg->Humans.size(); i++)
    {
        /* -------------------------------------------------------------------------- */
        /*                             Auxiliary Variables                            */
        /* -------------------------------------------------------------------------- */
        phaseStruct phase_;
        activityStruct activity_;
        /* -------------------------------------------------------------------------- */

        /* -------------------------------------------------------------------------- */
        /*                            Activity - Definition                           */
        /* -------------------------------------------------------------------------- */

        /* ------------------------------ Waiting Phase ----------------------------- */
        
        /* -------------------------------------------------------------------------- */

        /* ---------------------------------- Gains --------------------------------- */
        this->node_handler.getParam("/phases/going_phase_coefficient", k_1);
        /* -------------------------------------------------------------------------- */

        /* ------------------------ Going Phase - Definition ------------------------ */
        phase_.name = "GoingPhase";
        phase_.type = 0; // 0 - Moving phase (Forward Motion with L-path), 1 - Moving phase (Backward Motion with L-path), 2 - Moving phase (Motion with Linear Path), -1 - Waiting / Serving phase
        phase_.startTime = msg->GoingStart[i];
        phase_.endTime = msg->GoingFinish[i];
        phase_.allocated_time = msg->GoingFinish[i] - msg->GoingStart[i];
        phase_.desired_configuration << this->humans_positions_vector[msg->Humans[i]-1][0], k_1*this->humans_positions_vector[msg->Humans[i]-1][1], 0.0;
        phase_.switch_condition = std::make_pair<bool,bool>(false,false);
        /* -------------------------------------------------------------------------- */
        
        /* ------------------------- Going Phase - Push Back ------------------------ */
        activity_.nominal_start_time = msg->GoingStart[i];
        activity_.phase.push_back(phase_);
        /* -------------------------------------------------------------------------- */

        /* ----------------------- Waiting Phase - Definition ----------------------- */
        phase_.name = "WaitingPhase";
        phase_.type = -1; // 0 - Moving phase (Forward Motion with L-path), 1 - Moving phase (Backward Motion with L-path), 2 - Moving phase (Motion with Linear Path), -1 - Waiting / Serving phase
        phase_.startTime = msg->WaitingStart[i];
        phase_.endTime = msg->WaitingFinish[i];
        phase_.allocated_time = msg->WaitingFinish[i] - msg->WaitingStart[i];
        phase_.desired_configuration.setConstant(-1);
        phase_.switch_condition = std::make_pair<bool,bool>(true,static_cast<bool>(msg->FinishedFilling[i]));
        /* -------------------------------------------------------------------------- */

        /* ------------------------ Waiting Phase - Push Back ----------------------- */
        activity_.phase.push_back(phase_);
        /* -------------------------------------------------------------------------- */

        /* --------------------- Approaching Phase - Definition --------------------- */
        phase_.name = "ApproachingPhase";
        phase_.type = 2; // 0 - Moving phase (Forward Motion with L-path), 1 - Moving phase (Backward Motion with L-path), 2 - Moving phase (Motion with Linear Path), -1 - Waiting / Serving phase
        phase_.startTime = msg->ApproachingStart[i];
        phase_.endTime = msg->ApproachingFinish[i];
        phase_.allocated_time = msg->ApproachingFinish[i] - msg->ApproachingStart[i];
        phase_.desired_configuration << this->humans_positions_vector[msg->Humans[i]-1][0], this->humans_positions_vector[msg->Humans[i]-1][1], 0.0;
        phase_.switch_condition = std::make_pair<bool,bool>(false,false);
        std::cout << phase_.desired_configuration.transpose() << std::endl;
        /* -------------------------------------------------------------------------- */

        /* ---------------------- Approaching Phase - Push Back --------------------- */
        activity_.phase.push_back(phase_);
        /* -------------------------------------------------------------------------- */

        /* -------------------- Serving Phase - Pt.2 - Definition ------------------- */
        phase_.name = "ServingPhase";
        phase_.type = -1; // 0 - Moving phase (Forward Motion with L-path), 1 - Moving phase (Backward Motion with L-path), 2 - Moving phase (Motion with Linear Path), -1 - Waiting / Serving phase
        phase_.startTime = msg->ServingStart[i];
        phase_.endTime = msg->ServingFinish[i];
        phase_.allocated_time = msg->ServingFinish[i] - msg->ServingStart[i];
        phase_.desired_configuration.setConstant(-1);
        phase_.switch_condition = std::make_pair<bool,bool>(true,static_cast<bool>(msg->FinishedService[i]));
        /* -------------------------------------------------------------------------- */

        /* -------------------- Serving Phase - Pt.2 - Push Back -------------------- */
        activity_.phase.push_back(phase_);
        /* -------------------------------------------------------------------------- */

        /* ------------------------ Depot Phase - Definition ------------------------ */
        phase_.name = "DepotPhase";
        phase_.type = 1; // 0 - Moving phase (Forward Motion with L-path), 1 - Moving phase (Backward Motion with L-path), 2 - Moving phase (Motion with Linear Path), -1 - Waiting / Serving phase
        phase_.startTime = msg->DepotStart[i];
        phase_.endTime = msg->DepotFinish[i];
        phase_.allocated_time = msg->DepotFinish[i] - msg->DepotStart[i];
        phase_.desired_configuration << this->robots_vector[msg->RobotID - 1].get_home_configuration()(0), this->robots_vector[msg->RobotID - 1].get_home_configuration()(1),-PI;
        phase_.switch_condition = std::make_pair<bool,bool>(false,false);
        /* -------------------------------------------------------------------------- */

        /* ------------------------- Depot Phase - Push Back ------------------------ */
        activity_.phase.push_back(phase_);
        /* -------------------------------------------------------------------------- */

        /* -------------------------------------------------------------------------- */

        /* -------------------------------------------------------------------------- */

        /* -------------------------------------------------------------------------- */
        /*                            Activity - Push Back                            */
        /* -------------------------------------------------------------------------- */
        activities_vector_.push_back(activity_);
        /* -------------------------------------------------------------------------- */
    }
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
    /*                              Plan - Push Back                              */
    /* -------------------------------------------------------------------------- */

    /* -------------------------------- Push Back ------------------------------- */
    this->robots_vector[robot_ID-1].allocate_a_plan(activities_vector_);
    /* -------------------------------------------------------------------------- */

    /* -------------------------------------------------------------------------- */
}
/* -------------------------------------------------------------------------- */